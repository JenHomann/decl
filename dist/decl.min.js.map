{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/decl.ts","src/element_collector.ts","src/scope.ts","src/subscriptions/batched_mutation_subscription.ts","src/subscriptions/element_matches_subscription.ts","src/subscriptions/event_subscription.ts","src/subscriptions/matching_elements_subscription.ts","src/subscriptions/subscription.ts","src/subscriptions/trivial_subscription.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","scope_1","Scope","default","Decl","root","this","scope","buildRootScope","select","matcher","executor","getDefaultInstance","on","defaultInstance","document","documentElement","setDefaultInstance","decl","pristine","prototype","getScope","window","isArrayLike","value","toArray","arrayLike","Array","slice","TypeError","isMemberOfArrayLike","haystack","needle","indexOf","ElementCollector","isMatchingElement","rootElement","elementMatcher","getInstance","collectMatchingElements","instance","element","ELEMENT_MATCHER_TYPE_ERROR_MESSAGE","cssSelector","isMatchingElementFromCssSelector","object","isMatchingElementFromObject","elementVistor","isMatchingElementFromElementVistor","collectMatchingElementsFromCssSelector","collectMatchingElementsFromObject","collectMatchingElementsFromElementVistor","matches","querySelectorAll","Element","visitorResult","isMatch","elements","_i","_a","children","child","element_1","push","apply","trivial_subscription_1","matching_elements_subscription_1","element_matches_subscription_1","event_subscription_1","isActivated","subscriptions","activate","getElement","match","addSubscription","TrivialSubscription","connected","unmatch","disconnected","MatchingElementsSubscription","buildSelectExecutor","when","ElementMatchesSubscription","buildWhenExecutor","EventSubscription","subscription","disconnect","splice","connect","deactivate","removeSubscription","index","scopes","event","addedElements","_b","_c","removedElements","element_2","length_1","_this","isMatching","subscription_1","Subscription","SubscriptionEvent","BatchedMutationSubscription","_super","isListening","handleMutationTimeout","mutationCallback","deferHandleMutations","mutationObserver","MutationObserver","__extends","startListening","observe","mutationObserverInit","stopListening","handleMutationsNow","setTimeout","takeRecords","handleMutations","clearTimeout","childList","attributes","characterData","subtree","batched_mutation_subscription_1","element_collector_1","isConnected","updateIsMatchingElement","computeIsMatchingElement","wasMatchingElement","event_1","ElementMatchesChangedEvent","elementMatchesSubscription","eventMatcher","eventNames","parseEventMatcher","eventListener","handleEvent","eventName","addEventListener","removeEventListener","split","arraySubtract","minuend","subtrahend","difference","minuend_1","member","matchingElements","updateMatchingElements","previouslyMatchingElements","MatchingElementsChangedEvent","matchingElementsSubscription","name","config"],"mappings":"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","file":"decl.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import { Scope, ScopeExecutor, ElementMatcher, EventMatcher, SubscriptionExecutor } from './scope';\n\nexport default Decl;\n\nexport class Decl {\n    private static defaultInstance: Decl;\n\n    static select(matcher: ElementMatcher, executor: ScopeExecutor): Scope {\n        return this.getDefaultInstance().select(matcher, executor);\n    }\n\n    static on(matcher: EventMatcher, executor: SubscriptionExecutor): Scope {\n        return this.getDefaultInstance().on(matcher, executor);\n    }\n\n    static getDefaultInstance() : Decl {\n        return this.defaultInstance || (this.defaultInstance = new Decl(document.documentElement));\n    }\n\n    static setDefaultInstance(decl: Decl) : Decl {\n        return this.defaultInstance = decl;\n    }\n\n    static pristine(): void {\n        if(this.defaultInstance) {\n            this.defaultInstance.pristine();\n            this.defaultInstance = null;\n        }\n    }\n\n    private scope: Scope;\n\n    constructor(root: Element) {\n        this.scope = Scope.buildRootScope(root);\n    }\n\n    select(matcher: ElementMatcher, executor: ScopeExecutor): Scope {\n        return this.getScope().select(matcher, executor);\n    }\n\n    on(matcher: EventMatcher, executor: SubscriptionExecutor): Scope {\n        return this.getScope().on(matcher, executor);\n    }\n\n    getScope(): Scope {\n        return this.scope;\n    }\n\n    pristine(): void {\n        this.scope.pristine();\n    }\n}\n\n// Export to a global for the browser (there *has* to be a better way to do this!)\nif(typeof(window) !== 'undefined') {\n    (<any>window).Decl = Decl;\n}\n\nexport { Scope, ScopeExecutor, ElementMatcher, EventMatcher, SubscriptionExecutor };\n","export default ElementCollector;\n\nexport interface ElementVistor { (element: Element): ElementMatcher | boolean }\nexport declare type ElementMatcher = string | NodeListOf<Element> | Element[] | ElementVistor;\n\nexport class ElementCollector {\n    private static instance: ElementCollector;\n    \n    private static readonly ELEMENT_MATCHER_TYPE_ERROR_MESSAGE = \"Decl: An `ElementMatcher` must be a CSS selector (string) or a function which takes a node under consideration and returns a CSS selector (string) that matches all matching nodes in the subtree, an array-like object of matching nodes in the subtree, or a boolean value as to whether the node should be included (in this case, the function will be invoked again for all children of the node).\";\n\n    static isMatchingElement(rootElement: Element, elementMatcher: ElementMatcher): boolean {\n        return this.getInstance().isMatchingElement(rootElement, elementMatcher);\n    }\n\n    static collectMatchingElements(rootElement: Element, elementMatcher: ElementMatcher): Element[] {\n        return this.getInstance().collectMatchingElements(rootElement, elementMatcher);\n    }\n\n    private static getInstance() : ElementCollector {\n        return this.instance || (this.instance = new ElementCollector());\n    }\n\n    isMatchingElement(element: Element, elementMatcher: ElementMatcher): boolean {\n        switch(typeof(elementMatcher)) {\n            default:\n                throw new TypeError(ElementCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n                \n            case 'string':\n                let cssSelector: string = <string>elementMatcher;\n                return this.isMatchingElementFromCssSelector(element, cssSelector);\n            \n            case 'object':\n                let object = <Object>elementMatcher;\n                return this.isMatchingElementFromObject(element, object);\n                \n            case 'function':\n                let elementVistor = <ElementVistor>elementMatcher;\n                return this.isMatchingElementFromElementVistor(element, elementVistor);       \n        }\n    }\n\n    collectMatchingElements(element: Element, elementMatcher: ElementMatcher): Element[] {\n        switch(typeof(elementMatcher)) {\n            default:\n                throw new TypeError(ElementCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n                \n            case 'string':\n                let cssSelector: string = <string>elementMatcher;\n                return this.collectMatchingElementsFromCssSelector(element, cssSelector);\n\n            case 'object':\n                let object = <Object>elementMatcher;\n                return this.collectMatchingElementsFromObject(element, object);\n                \n            case 'function':\n                let elementVistor = <ElementVistor>elementMatcher;\n                return this.collectMatchingElementsFromElementVistor(element, elementVistor);       \n        }\n    }\n\n    private isMatchingElementFromCssSelector(element: Element, cssSelector: string): boolean {\n        if(typeof(element.matches) === 'function') { // take a shortcut in modern browsers\n            return element.matches(cssSelector);\n        }else{\n            return isMemberOfArrayLike(document.querySelectorAll(cssSelector), element);\n        }\n    }\n\n    private isMatchingElementFromObject(element: Element, object: Object): boolean {\n        if(object === null) {\n            return false;\n        }else{\n            if(isArrayLike(object)) {\n                let arrayLike = <ArrayLike<any>>object;\n\n                if(arrayLike.length === 0 || arrayLike[0] instanceof Element) {\n                    return isMemberOfArrayLike(arrayLike, element);                \n                }else{\n                    throw new TypeError(ElementCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n                }\n            }else{\n                throw new TypeError(ElementCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n            }\n        }\n    }\n\n    private isMatchingElementFromElementVistor(element: Element, elementVistor: ElementVistor): boolean {\n        let visitorResult = elementVistor(element);\n\n        if(typeof(visitorResult) === 'boolean') {\n            let isMatch = <boolean>visitorResult;\n            return isMatch;\n        }else{\n            let elementMatcher = <ElementMatcher>visitorResult;\n            return this.isMatchingElement(element, elementMatcher);\n        }\n    }\n\n    private collectMatchingElementsFromCssSelector(element: Element, cssSelector: string): Element[] {\n        return toArray<Element>(element.querySelectorAll(cssSelector));\n    }\n\n    private collectMatchingElementsFromObject(element: Element, object: Object): Element[] {\n        if(object === null) {\n            return [];\n        }else{\n            if(isArrayLike(object)) {\n                let arrayLike = <ArrayLike<any>>object;\n\n                if(arrayLike.length === 0 || arrayLike[0] instanceof Element) {\n                    return toArray<Element>(arrayLike);                \n                }else{\n                    throw new TypeError(ElementCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n                }\n            }else{\n                throw new TypeError(ElementCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n            }\n        }\n    }\n\n    private collectMatchingElementsFromElementVistor(element: Element, elementVistor: ElementVistor): Element[] {\n        let elements: Element[] = [];\n\n        // I'm fibbing to the compiler here. `element.children` is a `NodeListOf<Element>`,\n        // which does not have a compatable interface with `Array<Element>`; however, the\n        // generated code still works because it doesn't actually use very much of the \n        // `Array` interace (it really only assumes a numberic length property and keys for\n        // 0...length). Casting to `any` here destroys that type information, so the \n        // compiler can't tell there is an issue and allows it without an error.\n        for(let child of <any>element.children) {\n            if(child instanceof Element) {\n                let element: Element = child;\n                let visitorResult = elementVistor(element);\n\n                if(typeof(visitorResult) === 'boolean') {\n                    let isMatch = <boolean>visitorResult;\n\n                    if(isMatch) {\n                        elements.push(element);\n                    }\n                }else{\n                    elements.push(...this.collectMatchingElements(element, visitorResult));\n                }\n            }\n        }\n\n        return elements;\n    }\n}\n\nfunction isArrayLike(value: any) {\n    return typeof(value) === 'object' && typeof(value.length) === 'number';\n}\n\nfunction toArray<T>(arrayLike: ArrayLike<T>): Array<T> {\n    if(isArrayLike(arrayLike)) {\n        return Array.prototype.slice.call(arrayLike, 0);\n    }else{\n        throw new TypeError('Expected ArrayLike');\n    }\n}\n\nfunction isMemberOfArrayLike(haystack: ArrayLike<any>,  needle: any) {\n    return Array.prototype.indexOf.call(haystack, needle) !== -1;\n}\n","import { Subscription, SubscriptionExecutor } from './subscriptions/subscription';\nimport { TrivialSubscription } from './subscriptions/trivial_subscription';\nimport { MatchingElementsSubscription, MatchingElementsChangedEvent } from './subscriptions/matching_elements_subscription';\nimport { ElementMatchesSubscription, ElementMatchesChangedEvent, ElementMatcher } from './subscriptions/element_matches_subscription';\nimport { EventSubscription, EventMatcher } from './subscriptions/event_subscription';\n\nexport class Scope {\n    static buildRootScope(element: Element): Scope {\n        let scope = new Scope(element);\n\n        scope.activate();\n\n        return scope;\n    }\n\n    private readonly element: Element;\n    private isActivated: boolean = false;\n    private subscriptions: Subscription[] = [];\n    private children: Scope[] = [];\n\n    constructor(element: Element, executor?: ScopeExecutor) {\n        this.element = element;\n\n        if(executor) {\n            executor.call(this, this);\n        }\n    }\n\n    getElement(): Element {\n        return this.element;\n    }\n\n    match(executor: SubscriptionExecutor): Scope {\n        this.addSubscription(new TrivialSubscription(this.element, { connected: true }, executor));\n\n        return this;\n    }\n\n    unmatch(executor: SubscriptionExecutor): Scope {\n        this.addSubscription(new TrivialSubscription(this.element, { disconnected: true }, executor));\n\n        return this;\n    }\n\n    select(matcher: ElementMatcher, executor: ScopeExecutor): Scope {\n        this.addSubscription(new MatchingElementsSubscription(this.element, matcher, this.buildSelectExecutor(executor)));\n\n        return this;\n    }\n\n    when(matcher: ElementMatcher, executor: ScopeExecutor): Scope {\n\t\tthis.addSubscription(new ElementMatchesSubscription(this.element, matcher, this.buildWhenExecutor(executor)));\n\n        return this;\n    }\n\n    on(matcher: EventMatcher, executor: SubscriptionExecutor): Scope {\n        this.addSubscription(new EventSubscription(this.element, matcher, executor));\n\n        return this;\n    }\n\n    // This method is for testing\n    pristine(): void {\n        for(let subscription of this.subscriptions) {\n            subscription.disconnect();\n        }\n        \n        this.subscriptions.splice(0);\n    }\n\n    protected activate(): void {\n        if(!this.isActivated) {\n            this.isActivated = true;\n\n            for(let subscription of this.subscriptions) {\n                subscription.connect();\n            }\n        }\n    }\n\n    protected deactivate(): void {\n        if(this.isActivated) {\n            for(let subscription of this.subscriptions) {\n                subscription.disconnect();\n            }\n\n            this.isActivated = false;            \n        }\n    }\n\n    private addSubscription(subscription: Subscription): void {\n        this.subscriptions.push(subscription);\n\n        if(this.isActivated) {\n            subscription.connect();\n        }\n    }\n\n    private removeSubscription(subscription: Subscription): void {\n        var index = this.subscriptions.indexOf(subscription);\n\n        if(index >= 0) {\n            subscription.disconnect();\n\n            this.subscriptions.splice(index, 1);\n        }\n    }\n\n    private buildSelectExecutor(executor: ScopeExecutor): SubscriptionExecutor {\n        let scopes: Scope[] = [];\n\n        return (element: Element, event: MatchingElementsChangedEvent) => {\n            for(let element of event.addedElements) {\n                let scope = new Scope(element, executor);\n\n                scopes.push(scope);\t\n                scope.activate();\n            }\n\n            for(let element of event.removedElements) {\n                for(let index = 0, length = scopes.length, scope : Scope; index < length; index++) {\n                    scope = scopes[index];\n\n                    if(scope.element === element) {\n                        scope.deactivate();\n                        \n                        scopes.splice(index, 1);\n                        break;\n                    }\n                }\n            }\n        };\n    }\n\n    private buildWhenExecutor(executor: ScopeExecutor): SubscriptionExecutor {\n        let scope : Scope = null;\n\n        return (element: Element, event: ElementMatchesChangedEvent) => {\n            if(event.isMatching) {\n                scope = new Scope(this.element, executor);\n                scope.activate();\n            }else{\n                scope.deactivate();\n                scope = null;\n            }\n        };\n    }\n}\n\nexport interface ScopeExecutor { (scope: Scope): void };\nexport { ElementMatcher, EventMatcher, SubscriptionExecutor };\n","import { Subscription, SubscriptionExecutor, SubscriptionEvent } from './subscription';\n\nexport abstract class BatchedMutationSubscription extends Subscription {\n    static readonly mutationObserverInit: MutationObserverInit = {\n        childList: true,\n        attributes: true,\n        characterData: true,\n        subtree: true\n    };\n\n    private isListening : boolean = false;\n    private handleMutationTimeout : any = null;\n\n    private readonly mutationCallback: MutationCallback;\n    private readonly mutationObserver: MutationObserver;\n\n    constructor(element: Element, executor: SubscriptionExecutor) {\n        super(element, executor);\n\n        this.mutationCallback = (): void => {\n            this.deferHandleMutations();\n        }\n\n        this.mutationObserver = new MutationObserver(this.mutationCallback);\n    }\n\n    protected startListening(): void {\n        if(!this.isListening) {\n            this.mutationObserver.observe(this.element, BatchedMutationSubscription.mutationObserverInit);\n\n            this.isListening = true;\n        }\n    }\n\n    protected stopListening(): void {\n        if(this.isListening) {\n            this.mutationObserver.disconnect();\n            this.handleMutationsNow();\n\n            this.isListening = false;\n        }\n    }\n    \n    protected abstract handleMutations(): void;\n\n    private deferHandleMutations(): void {\n        if(this.handleMutationTimeout === null) {\n            this.handleMutationTimeout = setTimeout(() => { \n                try {\n                    this.mutationObserver.takeRecords();\n                    this.handleMutations();\n                }finally{\n                    this.handleMutationTimeout = null;\n                }\n            }, 0);\n        }\n    }\n\n    private handleMutationsNow(): void {\n        if(this.handleMutationTimeout !== null) {\n            clearTimeout(this.handleMutationTimeout);\n            this.handleMutationTimeout = null;\n\n            this.handleMutations();            \n        }\n    }\n}\n\nexport { Subscription, SubscriptionExecutor, SubscriptionEvent };","import { BatchedMutationSubscription, SubscriptionExecutor, SubscriptionEvent } from './batched_mutation_subscription';\nimport { ElementMatcher, ElementCollector } from '../element_collector';\n\nexport class ElementMatchesSubscription extends BatchedMutationSubscription {\n    readonly matcher: ElementMatcher;\n\n    private isConnected: boolean = false;\n    private isMatchingElement: boolean = false;\n\n    constructor(element: Element, matcher: ElementMatcher, executor: SubscriptionExecutor) {\n        super(element, executor);\n\n        this.matcher = matcher;\n    }\n\n    connect(): void {\n        if(!this.isConnected) {\n            this.updateIsMatchingElement(this.computeIsMatchingElement());\n            this.startListening();\n\n            this.isConnected = true;\n        }\n    }\n\n    disconnect(): void {\n        if(this.isConnected) {\n            this.updateIsMatchingElement(false);\n            this.stopListening();\n\n            this.isConnected = false;\n        }        \n    }\n\n    protected handleMutations(): void {\n        this.updateIsMatchingElement(this.computeIsMatchingElement());\n    }\n\n    private updateIsMatchingElement(isMatchingElement: boolean): void {\n        let wasMatchingElement = this.isMatchingElement;\n        this.isMatchingElement = isMatchingElement;\n\n        if(wasMatchingElement !== isMatchingElement) {\n            let event = new ElementMatchesChangedEvent(this, isMatchingElement);\n\n            this.executor(this.element, event);\n        }\n    }\n\n    private computeIsMatchingElement(): boolean {\n        return ElementCollector.isMatchingElement(this.element, this.matcher);\n    }\n}\n\nexport class ElementMatchesChangedEvent extends SubscriptionEvent {\n    readonly elementMatchesSubscription: ElementMatchesSubscription;\n    readonly isMatching: boolean;\n\n    constructor(elementMatchesSubscription: ElementMatchesSubscription, isMatching: boolean) {\n        super('ElementMatchesChangedEvent')\n\n        this.elementMatchesSubscription = elementMatchesSubscription;\n        this.isMatching = isMatching;\n    }\n}\n\nexport { ElementMatcher };\n","import { Subscription, SubscriptionExecutor } from './subscription';\n\nexport class EventSubscription extends Subscription {\n    readonly eventMatcher: EventMatcher;\n\n    private isConnected : boolean = false;    \n    private readonly eventListener: EventListener;\n    private readonly eventNames: string[];\n\n    constructor(element: Element, eventMatcher: EventMatcher, executor: SubscriptionExecutor) {\n        super(element, executor);\n\n        this.eventMatcher = eventMatcher;\n        this.eventNames = this.parseEventMatcher(this.eventMatcher);\n\n        this.eventListener = (event: Event): void => {\n            this.handleEvent(event);\n        }\n    }\n\n    connect(): void {\n        if(!this.isConnected) {\n            this.isConnected = true;\n\n            for(let eventName of this.eventNames) {\n                this.element.addEventListener(eventName, this.eventListener, false);\n            }\n        }\n    }\n\n    disconnect(): void {\n        if(this.isConnected) {\n            for(let eventName of this.eventNames) {\n                this.element.removeEventListener(eventName, this.eventListener, false);\n            }            \n\n            this.isConnected = false;\n        }\n    }\n\n    private handleEvent(event: Event): void {\n        this.executor(this.element, event);         \n    }\n\n    private parseEventMatcher(eventMatcher: EventMatcher): string[] {\n        // TODO: Support all of the jQuery style event options\n        return eventMatcher.split(' ');\n    } \n}\n\nexport declare type EventMatcher = string;\n","import { BatchedMutationSubscription, SubscriptionExecutor, SubscriptionEvent } from './batched_mutation_subscription';\nimport { ElementMatcher, ElementCollector } from '../element_collector';\n\nexport class MatchingElementsSubscription extends BatchedMutationSubscription {\n    readonly matcher: ElementMatcher;\n\n    private isConnected: boolean = false;\n    private matchingElements: Element[] = [];\n\n    constructor(element: Element, matcher: ElementMatcher, executor: SubscriptionExecutor) {\n        super(element, executor);\n\n        this.matcher = matcher;\n    }\n\n    connect(): void {\n        if(!this.isConnected) {\n            this.updateMatchingElements(this.collectMatchingElements());\n            this.startListening();\n\n            this.isConnected = true;\n        }\n    }\n\n    disconnect(): void {\n        if(this.isConnected) {\n            this.updateMatchingElements([]);\n            this.stopListening();\n\n            this.isConnected = false;\n        }        \n    }\n\n    protected handleMutations(): void {\n        this.updateMatchingElements(this.collectMatchingElements());\n    }\n\n    private updateMatchingElements(matchingElements: Element[]): void {\n        let previouslyMatchingElements = this.matchingElements;\n\n        let addedElements = arraySubtract(matchingElements, previouslyMatchingElements);\n        let removedElements = arraySubtract(previouslyMatchingElements, matchingElements);\n\n        this.matchingElements = matchingElements;   \n        \n        if(addedElements.length > 0 || removedElements.length > 0) {\n            let event = new MatchingElementsChangedEvent(this, addedElements, removedElements);\n\n            this.executor(this.element, event);\n        }\n    }\n\n    private collectMatchingElements(): Element[] {\n        return ElementCollector.collectMatchingElements(this.element, this.matcher);\n    }\n}\n\nexport class MatchingElementsChangedEvent extends SubscriptionEvent {\n    readonly matchingElementsSubscription: MatchingElementsSubscription;\n    readonly addedElements: Element[];\n    readonly removedElements: Element[];\n\n    constructor(matchingElementsSubscription: MatchingElementsSubscription, addedElements: Element[], removedElements: Element[]) {\n        super('MatchingElementsChanged')\n\n        this.matchingElementsSubscription = matchingElementsSubscription;\n        this.addedElements = addedElements;\n        this.removedElements = removedElements;\n    }\n}\n\nfunction arraySubtract<T>(minuend: T[], subtrahend: T[]): T[] {\n    let difference: T[] = [];\n\n    for(let member of minuend) {\n        if(subtrahend.indexOf(member) === -1) {\n            difference.push(member);\n        }\n    }\n\n    return difference;\n}","export abstract class Subscription {\n    protected readonly executor: SubscriptionExecutor;\n    protected readonly element: Element;\n    \n    constructor(element: Element, executor: SubscriptionExecutor) {\n        this.element = element;\n        this.executor = executor;\n    }\n\n    abstract connect() : void;\n    abstract disconnect() : void;\n}\n\nexport interface SubscriptionExecutor { \n    (element: Element, event?: Event | SubscriptionEvent): void \n}\n\nexport class SubscriptionEvent {\n    readonly name : string;\n\n    constructor(name : string) {\n        this.name = name;\n    }\n}\n","import { Subscription, SubscriptionExecutor } from './subscription';\n\nexport interface TrivialSubscriptionConfiguration {\n    connected?: boolean,\n    disconnected?: boolean\n}\n\nexport class TrivialSubscription extends Subscription {\n    private isConnected: boolean = false;\n    private config: TrivialSubscriptionConfiguration;\n\n    constructor(element: Element, config: TrivialSubscriptionConfiguration, executor: SubscriptionExecutor) {\n        super(element, executor);\n\n        this.config = config;\n    }\n\n    connect() {\n        if(!this.isConnected) {\n            this.isConnected = true;\n\n            if(this.config.connected) {\n                this.executor(this.element);            \n            }\n        }\n    }\n\n    disconnect() {\n        if(this.isConnected) {\n            this.isConnected = false;\n\n            if(this.config.disconnected) {\n                this.executor(this.element);            \n            }\n        }\n    }\n}"]}