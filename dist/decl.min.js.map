{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/mutation-observer/index.js","src/decl.ts","src/declarations/declaration.ts","src/declarations/match_declaration.ts","src/declarations/on_declaration.ts","src/declarations/scope_tracking_declaration.ts","src/declarations/select_declaration.ts","src/declarations/unmatch_declaration.ts","src/declarations/when_declaration.ts","src/node_collector.ts","src/scope.ts","src/subscriptions/batched_mutation_subscription.ts","src/subscriptions/event_subscription.ts","src/subscriptions/matching_nodes_subscription.ts","src/subscriptions/node_matches_subscription.ts","src/subscriptions/subscription.ts","src/subscriptions/trivial_subscription.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","scheduleCallback","observer","scheduledObservers","push","isScheduled","setImmediate","dispatchCallbacks","wrapIfNeeded","node","window","ShadowDOMPolyfill","observers","sort","o1","o2","uid_","anyNonEmpty","forEach","queue","takeRecords","removeTransientObserversFor","callback_","nodes_","registrations","registrationsTable","get","registration","removeTransientObservers","forEachAncestorAndObserverEnqueueRecord","target","callback","parentNode","j","options","subtree","record","enqueue","JsMutationObserver","this","records_","uidCounter","MutationRecord","type","addedNodes","removedNodes","previousSibling","nextSibling","attributeName","attributeNamespace","oldValue","copyMutationRecord","original","slice","getRecord","currentRecord","getRecordWithOldValue","recordWithOldValue","clearRecords","undefined","recordRepresentsCurrentMutation","selectRecord","lastRecord","newRecord","Registration","transientObservedNodes","MutationObserver","WebKitMutationObserver","MozMutationObserver","WeakMap","defineProperty","Object","counter","Date","now","name","Math","random","prototype","set","key","value","entry","writable","delete","hasValue","has","msSetImmediate","setImmediateQueue","sentinel","String","addEventListener","data","func","postMessage","observe","childList","attributes","characterData","attributeOldValue","attributeFilter","characterDataOldValue","SyntaxError","removeListeners","addListeners","disconnect","splice","copyOfRecords","records","recordToReplaceLast","addListeners_","removeListeners_","removeEventListener","addTransientObserver","handleEvent","stopImmediatePropagation","attrName","namespace","relatedNode","namespaceURI","attrChange","MutationEvent","ADDITION","prevValue","indexOf","changedNode","scope_1","Scope","Decl","root","scope","buildRootScope","select","matcher","executor","getDefaultInstance","on","getRootScope","inspect","includeSource","defaultInstance","document","setDefaultInstance","decl","pristine","console","groupCollapsed","groupEnd","default","Declaration","isActivated","activate","subscription","connect","deactivate","declaration_1","trivial_subscription_1","MatchDeclaration","_super","_this","TrivialSubscription","connected","__extends","log","event_subscription_1","OnDeclaration","EventSubscription","ScopeTrackingDeclaration","apply","arguments","childScopes","removeAllChildScopes","getChildScopes","inspectChildScopes","_i","_a","addChildScope","removeChildScope","index","childScope","addChildScopeByNode","removeChildScopeByNode","getNode","scope_tracking_declaration_1","matching_nodes_subscription_1","SelectDeclaration","MatchingNodesSubscription","event","node_1","_b","_c","node_2","UnmatchDeclaration","disconnected","node_matches_subscription_1","WhenDeclaration","NodeMatchesSubscription","isMatching","isArrayLike","toArray","arrayLike","Array","TypeError","isMemberOfArrayLike","haystack","needle","NodeCollector","isMatchingNode","rootNode","nodeMatcher","getInstance","collectMatchingNodes","instance","ELEMENT_MATCHER_TYPE_ERROR_MESSAGE","cssSelector","isMatchingNodeFromCssSelector","object","isMatchingNodeFromObject","nodeVistor","isMatchingNodeFromNodeVistor","collectMatchingNodesFromCssSelector","collectMatchingNodesFromObject","collectMatchingNodesFromNodeVistor","Element","matches","ownerDocument","querySelectorAll","Node","visitorResult","Document","DocumentFragment","_node","nodes","childNodes","length_1","child","match_declaration_1","unmatch_declaration_1","on_declaration_1","select_declaration_1","when_declaration_1","executors","declarations","addExecutor","getDeclarations","removeAllDeclarations","match","addDeclaration","unmatch","when","eventMatcher","executorOrNodeMatcher","maybeExecutor","argumentsCount","onWithTwoArguments","onWithThreeArguments","declaration","removeDeclaration","subscription_1","Subscription","SubscriptionEvent","BatchedMutationSubscription","isListening","handleMutationTimeout","mutationCallback","deferHandleMutations","mutationObserver","startListening","mutationObserverInit","stopListening","handleMutationsNow","setTimeout","handleMutations","clearTimeout","isConnected","eventNames","parseEventMatcher","eventListener","eventName","split","arraySubtract","minuend","subtrahend","difference","minuend_1","member","batched_mutation_subscription_1","node_collector_1","matchingNodes","updateMatchingNode","previouslyMatchingNodes","event_1","MatchingNodesChangedEvent","matchingNodesSubscription","updateIsMatchingNode","computeIsMatchingNode","wasMatchingNode","NodeMatchesChangedEvent","nodeMatchesSubscription","NodeConnectionChangedEvent","trivialSubscription","config","buildNodeConnectionChangedEvent"],"mappings":"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","file":"decl.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var MutationObserver = window.MutationObserver\n  || window.WebKitMutationObserver\n  || window.MozMutationObserver;\n\n/*\n * Copyright 2012 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\nvar WeakMap = window.WeakMap;\n\nif (typeof WeakMap === 'undefined') {\n  var defineProperty = Object.defineProperty;\n  var counter = Date.now() % 1e9;\n\n  WeakMap = function() {\n    this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');\n  };\n\n  WeakMap.prototype = {\n    set: function(key, value) {\n      var entry = key[this.name];\n      if (entry && entry[0] === key)\n        entry[1] = value;\n      else\n        defineProperty(key, this.name, {value: [key, value], writable: true});\n      return this;\n    },\n    get: function(key) {\n      var entry;\n      return (entry = key[this.name]) && entry[0] === key ?\n          entry[1] : undefined;\n    },\n    'delete': function(key) {\n      var entry = key[this.name];\n      if (!entry) return false;\n      var hasValue = entry[0] === key;\n      entry[0] = entry[1] = undefined;\n      return hasValue;\n    },\n    has: function(key) {\n      var entry = key[this.name];\n      if (!entry) return false;\n      return entry[0] === key;\n    }\n  };\n}\n\nvar registrationsTable = new WeakMap();\n\n// We use setImmediate or postMessage for our future callback.\nvar setImmediate = window.msSetImmediate;\n\n// Use post message to emulate setImmediate.\nif (!setImmediate) {\n  var setImmediateQueue = [];\n  var sentinel = String(Math.random());\n  window.addEventListener('message', function(e) {\n    if (e.data === sentinel) {\n      var queue = setImmediateQueue;\n      setImmediateQueue = [];\n      queue.forEach(function(func) {\n        func();\n      });\n    }\n  });\n  setImmediate = function(func) {\n    setImmediateQueue.push(func);\n    window.postMessage(sentinel, '*');\n  };\n}\n\n// This is used to ensure that we never schedule 2 callas to setImmediate\nvar isScheduled = false;\n\n// Keep track of observers that needs to be notified next time.\nvar scheduledObservers = [];\n\n/**\n * Schedules |dispatchCallback| to be called in the future.\n * @param {MutationObserver} observer\n */\nfunction scheduleCallback(observer) {\n  scheduledObservers.push(observer);\n  if (!isScheduled) {\n    isScheduled = true;\n    setImmediate(dispatchCallbacks);\n  }\n}\n\nfunction wrapIfNeeded(node) {\n  return window.ShadowDOMPolyfill &&\n      window.ShadowDOMPolyfill.wrapIfNeeded(node) ||\n      node;\n}\n\nfunction dispatchCallbacks() {\n  // http://dom.spec.whatwg.org/#mutation-observers\n\n  isScheduled = false; // Used to allow a new setImmediate call above.\n\n  var observers = scheduledObservers;\n  scheduledObservers = [];\n  // Sort observers based on their creation UID (incremental).\n  observers.sort(function(o1, o2) {\n    return o1.uid_ - o2.uid_;\n  });\n\n  var anyNonEmpty = false;\n  observers.forEach(function(observer) {\n\n    // 2.1, 2.2\n    var queue = observer.takeRecords();\n    // 2.3. Remove all transient registered observers whose observer is mo.\n    removeTransientObserversFor(observer);\n\n    // 2.4\n    if (queue.length) {\n      observer.callback_(queue, observer);\n      anyNonEmpty = true;\n    }\n  });\n\n  // 3.\n  if (anyNonEmpty)\n    dispatchCallbacks();\n}\n\nfunction removeTransientObserversFor(observer) {\n  observer.nodes_.forEach(function(node) {\n    var registrations = registrationsTable.get(node);\n    if (!registrations)\n      return;\n    registrations.forEach(function(registration) {\n      if (registration.observer === observer)\n        registration.removeTransientObservers();\n    });\n  });\n}\n\n/**\n * This function is used for the \"For each registered observer observer (with\n * observer's options as options) in target's list of registered observers,\n * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n * each registered observer observer (with options options) in ancestor's list\n * of registered observers, run these substeps:\" part of the algorithms. The\n * |options.subtree| is checked to ensure that the callback is called\n * correctly.\n *\n * @param {Node} target\n * @param {function(MutationObserverInit):MutationRecord} callback\n */\nfunction forEachAncestorAndObserverEnqueueRecord(target, callback) {\n  for (var node = target; node; node = node.parentNode) {\n    var registrations = registrationsTable.get(node);\n\n    if (registrations) {\n      for (var j = 0; j < registrations.length; j++) {\n        var registration = registrations[j];\n        var options = registration.options;\n\n        // Only target ignores subtree.\n        if (node !== target && !options.subtree)\n          continue;\n\n        var record = callback(options);\n        if (record)\n          registration.enqueue(record);\n      }\n    }\n  }\n}\n\nvar uidCounter = 0;\n\n/**\n * The class that maps to the DOM MutationObserver interface.\n * @param {Function} callback.\n * @constructor\n */\nfunction JsMutationObserver(callback) {\n  this.callback_ = callback;\n  this.nodes_ = [];\n  this.records_ = [];\n  this.uid_ = ++uidCounter;\n}\n\nJsMutationObserver.prototype = {\n  observe: function(target, options) {\n    target = wrapIfNeeded(target);\n\n    // 1.1\n    if (!options.childList && !options.attributes && !options.characterData ||\n\n        // 1.2\n        options.attributeOldValue && !options.attributes ||\n\n        // 1.3\n        options.attributeFilter && options.attributeFilter.length &&\n            !options.attributes ||\n\n        // 1.4\n        options.characterDataOldValue && !options.characterData) {\n\n      throw new SyntaxError();\n    }\n\n    var registrations = registrationsTable.get(target);\n    if (!registrations)\n      registrationsTable.set(target, registrations = []);\n\n    // 2\n    // If target's list of registered observers already includes a registered\n    // observer associated with the context object, replace that registered\n    // observer's options with options.\n    var registration;\n    for (var i = 0; i < registrations.length; i++) {\n      if (registrations[i].observer === this) {\n        registration = registrations[i];\n        registration.removeListeners();\n        registration.options = options;\n        break;\n      }\n    }\n\n    // 3.\n    // Otherwise, add a new registered observer to target's list of registered\n    // observers with the context object as the observer and options as the\n    // options, and add target to context object's list of nodes on which it\n    // is registered.\n    if (!registration) {\n      registration = new Registration(this, target, options);\n      registrations.push(registration);\n      this.nodes_.push(target);\n    }\n\n    registration.addListeners();\n  },\n\n  disconnect: function() {\n    this.nodes_.forEach(function(node) {\n      var registrations = registrationsTable.get(node);\n      for (var i = 0; i < registrations.length; i++) {\n        var registration = registrations[i];\n        if (registration.observer === this) {\n          registration.removeListeners();\n          registrations.splice(i, 1);\n          // Each node can only have one registered observer associated with\n          // this observer.\n          break;\n        }\n      }\n    }, this);\n    this.records_ = [];\n  },\n\n  takeRecords: function() {\n    var copyOfRecords = this.records_;\n    this.records_ = [];\n    return copyOfRecords;\n  }\n};\n\n/**\n * @param {string} type\n * @param {Node} target\n * @constructor\n */\nfunction MutationRecord(type, target) {\n  this.type = type;\n  this.target = target;\n  this.addedNodes = [];\n  this.removedNodes = [];\n  this.previousSibling = null;\n  this.nextSibling = null;\n  this.attributeName = null;\n  this.attributeNamespace = null;\n  this.oldValue = null;\n}\n\nfunction copyMutationRecord(original) {\n  var record = new MutationRecord(original.type, original.target);\n  record.addedNodes = original.addedNodes.slice();\n  record.removedNodes = original.removedNodes.slice();\n  record.previousSibling = original.previousSibling;\n  record.nextSibling = original.nextSibling;\n  record.attributeName = original.attributeName;\n  record.attributeNamespace = original.attributeNamespace;\n  record.oldValue = original.oldValue;\n  return record;\n};\n\n// We keep track of the two (possibly one) records used in a single mutation.\nvar currentRecord, recordWithOldValue;\n\n/**\n * Creates a record without |oldValue| and caches it as |currentRecord| for\n * later use.\n * @param {string} oldValue\n * @return {MutationRecord}\n */\nfunction getRecord(type, target) {\n  return currentRecord = new MutationRecord(type, target);\n}\n\n/**\n * Gets or creates a record with |oldValue| based in the |currentRecord|\n * @param {string} oldValue\n * @return {MutationRecord}\n */\nfunction getRecordWithOldValue(oldValue) {\n  if (recordWithOldValue)\n    return recordWithOldValue;\n  recordWithOldValue = copyMutationRecord(currentRecord);\n  recordWithOldValue.oldValue = oldValue;\n  return recordWithOldValue;\n}\n\nfunction clearRecords() {\n  currentRecord = recordWithOldValue = undefined;\n}\n\n/**\n * @param {MutationRecord} record\n * @return {boolean} Whether the record represents a record from the current\n * mutation event.\n */\nfunction recordRepresentsCurrentMutation(record) {\n  return record === recordWithOldValue || record === currentRecord;\n}\n\n/**\n * Selects which record, if any, to replace the last record in the queue.\n * This returns |null| if no record should be replaced.\n *\n * @param {MutationRecord} lastRecord\n * @param {MutationRecord} newRecord\n * @param {MutationRecord}\n */\nfunction selectRecord(lastRecord, newRecord) {\n  if (lastRecord === newRecord)\n    return lastRecord;\n\n  // Check if the the record we are adding represents the same record. If\n  // so, we keep the one with the oldValue in it.\n  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))\n    return recordWithOldValue;\n\n  return null;\n}\n\n/**\n * Class used to represent a registered observer.\n * @param {MutationObserver} observer\n * @param {Node} target\n * @param {MutationObserverInit} options\n * @constructor\n */\nfunction Registration(observer, target, options) {\n  this.observer = observer;\n  this.target = target;\n  this.options = options;\n  this.transientObservedNodes = [];\n}\n\nRegistration.prototype = {\n  enqueue: function(record) {\n    var records = this.observer.records_;\n    var length = records.length;\n\n    // There are cases where we replace the last record with the new record.\n    // For example if the record represents the same mutation we need to use\n    // the one with the oldValue. If we get same record (this can happen as we\n    // walk up the tree) we ignore the new record.\n    if (records.length > 0) {\n      var lastRecord = records[length - 1];\n      var recordToReplaceLast = selectRecord(lastRecord, record);\n      if (recordToReplaceLast) {\n        records[length - 1] = recordToReplaceLast;\n        return;\n      }\n    } else {\n      scheduleCallback(this.observer);\n    }\n\n    records[length] = record;\n  },\n\n  addListeners: function() {\n    this.addListeners_(this.target);\n  },\n\n  addListeners_: function(node) {\n    var options = this.options;\n    if (options.attributes)\n      node.addEventListener('DOMAttrModified', this, true);\n\n    if (options.characterData)\n      node.addEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList)\n      node.addEventListener('DOMNodeInserted', this, true);\n\n    if (options.childList || options.subtree)\n      node.addEventListener('DOMNodeRemoved', this, true);\n  },\n\n  removeListeners: function() {\n    this.removeListeners_(this.target);\n  },\n\n  removeListeners_: function(node) {\n    var options = this.options;\n    if (options.attributes)\n      node.removeEventListener('DOMAttrModified', this, true);\n\n    if (options.characterData)\n      node.removeEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList)\n      node.removeEventListener('DOMNodeInserted', this, true);\n\n    if (options.childList || options.subtree)\n      node.removeEventListener('DOMNodeRemoved', this, true);\n  },\n\n  /**\n   * Adds a transient observer on node. The transient observer gets removed\n   * next time we deliver the change records.\n   * @param {Node} node\n   */\n  addTransientObserver: function(node) {\n    // Don't add transient observers on the target itself. We already have all\n    // the required listeners set up on the target.\n    if (node === this.target)\n      return;\n\n    this.addListeners_(node);\n    this.transientObservedNodes.push(node);\n    var registrations = registrationsTable.get(node);\n    if (!registrations)\n      registrationsTable.set(node, registrations = []);\n\n    // We know that registrations does not contain this because we already\n    // checked if node === this.target.\n    registrations.push(this);\n  },\n\n  removeTransientObservers: function() {\n    var transientObservedNodes = this.transientObservedNodes;\n    this.transientObservedNodes = [];\n\n    transientObservedNodes.forEach(function(node) {\n      // Transient observers are never added to the target.\n      this.removeListeners_(node);\n\n      var registrations = registrationsTable.get(node);\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i] === this) {\n          registrations.splice(i, 1);\n          // Each node can only have one registered observer associated with\n          // this observer.\n          break;\n        }\n      }\n    }, this);\n  },\n\n  handleEvent: function(e) {\n    // Stop propagation since we are managing the propagation manually.\n    // This means that other mutation events on the page will not work\n    // correctly but that is by design.\n    e.stopImmediatePropagation();\n\n    switch (e.type) {\n      case 'DOMAttrModified':\n        // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n\n        var name = e.attrName;\n        var namespace = e.relatedNode.namespaceURI;\n        var target = e.target;\n\n        // 1.\n        var record = new getRecord('attributes', target);\n        record.attributeName = name;\n        record.attributeNamespace = namespace;\n\n        // 2.\n        var oldValue =\n            e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          // 3.1, 4.2\n          if (!options.attributes)\n            return;\n\n          // 3.2, 4.3\n          if (options.attributeFilter && options.attributeFilter.length &&\n              options.attributeFilter.indexOf(name) === -1 &&\n              options.attributeFilter.indexOf(namespace) === -1) {\n            return;\n          }\n          // 3.3, 4.4\n          if (options.attributeOldValue)\n            return getRecordWithOldValue(oldValue);\n\n          // 3.4, 4.5\n          return record;\n        });\n\n        break;\n\n      case 'DOMCharacterDataModified':\n        // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n        var target = e.target;\n\n        // 1.\n        var record = getRecord('characterData', target);\n\n        // 2.\n        var oldValue = e.prevValue;\n\n\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          // 3.1, 4.2\n          if (!options.characterData)\n            return;\n\n          // 3.2, 4.3\n          if (options.characterDataOldValue)\n            return getRecordWithOldValue(oldValue);\n\n          // 3.3, 4.4\n          return record;\n        });\n\n        break;\n\n      case 'DOMNodeRemoved':\n        this.addTransientObserver(e.target);\n        // Fall through.\n      case 'DOMNodeInserted':\n        // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n        var target = e.relatedNode;\n        var changedNode = e.target;\n        var addedNodes, removedNodes;\n        if (e.type === 'DOMNodeInserted') {\n          addedNodes = [changedNode];\n          removedNodes = [];\n        } else {\n\n          addedNodes = [];\n          removedNodes = [changedNode];\n        }\n        var previousSibling = changedNode.previousSibling;\n        var nextSibling = changedNode.nextSibling;\n\n        // 1.\n        var record = getRecord('childList', target);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling;\n        record.nextSibling = nextSibling;\n\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          // 2.1, 3.2\n          if (!options.childList)\n            return;\n\n          // 2.2, 3.3\n          return record;\n        });\n\n    }\n\n    clearRecords();\n  }\n};\n\nif (!MutationObserver) {\n  MutationObserver = JsMutationObserver;\n}\n\nmodule.exports = MutationObserver;\n","import { Scope, NodeMatcher, EventMatcher, ScopeExecutor, SubscriptionExecutor } from './scope';\n\nexport { Scope, NodeMatcher, EventMatcher, ScopeExecutor, SubscriptionExecutor };\n\nexport class Decl {\n    private static defaultInstance: Decl | null = null;\n\n    static select(matcher: NodeMatcher, executor: ScopeExecutor): Scope {\n        return this.getDefaultInstance().select(matcher, executor);\n    }\n\n    static on(matcher: EventMatcher, executor: SubscriptionExecutor): Scope {\n        return this.getDefaultInstance().on(matcher, executor);\n    }\n\n    static getRootScope(): Scope {\n        return this.getDefaultInstance().getRootScope();\n    }\n\n    static inspect(includeSource?: boolean): void {\n        this.getDefaultInstance().inspect(includeSource);\n    }\n\n    static getDefaultInstance() : Decl {\n        return this.defaultInstance || (this.defaultInstance = new Decl(window.document));\n    }\n\n    static setDefaultInstance(decl: Decl) : Decl {\n        return this.defaultInstance = decl;\n    }\n\n    static pristine(): void {\n        if(this.defaultInstance) {\n            this.defaultInstance.pristine();\n            this.defaultInstance = null;\n        }\n    }\n\n    private scope: Scope;\n\n    constructor(root: Node) {\n        this.scope = Scope.buildRootScope(root);\n    }\n\n    select(matcher: NodeMatcher, executor: ScopeExecutor): Scope {\n        return this.scope.select(matcher, executor);\n    }\n\n    on(matcher: EventMatcher, executor: SubscriptionExecutor): Scope {\n        return this.scope.on(matcher, executor);\n    }\n\n    getRootScope(): Scope {\n       return this.scope; \n    }\n\n    inspect(includeSource?: boolean): void {\n        console.groupCollapsed('<<root>>');\n        \n        try {\n            this.scope.inspect(includeSource);        \n        }finally{\n            console.groupEnd();\n        }\n    }\n\n    pristine(): void {\n        this.scope.pristine();\n    }\n}\n\n// Export to a global for the browser (there *has* to be a better way to do this!)\nif(typeof(window) !== 'undefined') {\n    (<any>window).Decl = Decl;\n}\n\nexport default Decl;\n","import { Subscription, SubscriptionExecutor } from '../subscriptions/subscription';\n\nexport { SubscriptionExecutor };\n\nexport abstract class Declaration {\n    protected isActivated: boolean = false;\n    protected readonly node: Node;\n    protected readonly subscription: Subscription;\n\n    constructor(node: Node) {\n        this.node = node;\n    }\n\n    activate(): void {\n        if(!this.isActivated) {\n            this.isActivated = true;\n\n            this.subscription.connect();\n        }\n    }\n\n    deactivate(): void {\n        if(this.isActivated) {\n            this.isActivated = false;\n\n            this.subscription.disconnect();\n        }        \n    }\n\n    abstract inspect(includeSource?: boolean): void;\n}","import { Declaration, SubscriptionExecutor } from './declaration';\nimport { TrivialSubscription } from '../subscriptions/trivial_subscription';\n\nexport { SubscriptionExecutor };\n\nexport class MatchDeclaration extends Declaration {\n    protected readonly subscription: TrivialSubscription;\n    protected readonly executor: SubscriptionExecutor;\n\n    constructor(node: Node, executor: SubscriptionExecutor) {\n        super(node);\n\n        this.executor = executor;\n\n        this.subscription = new TrivialSubscription(this.node, { connected: true }, this.executor);\n    }\n\n    inspect(): void {\n        console.groupCollapsed('matches');\n        console.log(this.executor);\n        console.groupEnd();\n    }\n}","import { Declaration, SubscriptionExecutor } from './declaration';\nimport { EventSubscription, EventMatcher } from '../subscriptions/event_subscription';\n\nexport { EventMatcher, SubscriptionExecutor };\n\nexport class OnDeclaration extends Declaration {\n    protected subscription: EventSubscription;\n    protected matcher: EventMatcher;\n    protected executor: SubscriptionExecutor;\n\n    constructor(node: Node, matcher: EventMatcher, executor: SubscriptionExecutor) {\n        super(node);\n\n        this.matcher = matcher;\n        this.executor = executor;\n\n        this.subscription = new EventSubscription(this.node, this.matcher, this.executor);    \n    }\n\n    inspect(): void {\n        (<any>console.groupCollapsed)('on', this.matcher);\n\n        try {\n            console.log(this.executor);\n        }finally{\n            console.groupEnd();\n        }\n    }\n}","import { Declaration } from './declaration';\nimport { NodeMatcher } from '../node_collector';\nimport { Scope, ScopeExecutor } from '../scope';\n\nexport { NodeMatcher, ScopeExecutor };\n\nexport abstract class ScopeTrackingDeclaration extends Declaration {\n    private readonly childScopes: Scope[] = [];\n    \n    deactivate(): void {\n        this.removeAllChildScopes();\n        super.deactivate();\n    }\n\n    getChildScopes() {\n        return this.childScopes;\n    }\n\n    protected inspectChildScopes(includeSource?: boolean): void {        \n        for(let childScope of this.childScopes) {\n            childScope.inspect(includeSource);\n        }\n    }\n\n    protected addChildScope(scope: Scope) {\n        if(this.isActivated) {\n            this.childScopes.push(scope);\n\n            scope.activate();\n        }\n    }\n\n    protected removeChildScope(scope: Scope) { \n        scope.deactivate();\n\n        if(this.isActivated) {\n            let index = this.childScopes.indexOf(scope);\n            \n            if(index >= 0) {\n                this.childScopes.splice(index, 1);\n            }\n        }\n    }\n\n    protected removeAllChildScopes() {\n        let childScope: Scope;\n\n        while(childScope = this.childScopes[0]) {\n            this.removeChildScope(childScope);\n        }\n    }\n\n    protected addChildScopeByNode(node: Node, executor?: ScopeExecutor) {\n        let childScope = new Scope(node, executor);\n\n        this.addChildScope(childScope);\n    }\n\n    protected removeChildScopeByNode(node: Node) {\n        for(let childScope of this.childScopes) {\n            if(childScope.getNode() === node) {\n                this.removeChildScope(childScope);\n                return; // loop must exist to avoid data-race\n            }\n        }\n    }\n}","import { ScopeTrackingDeclaration, NodeMatcher, ScopeExecutor } from './scope_tracking_declaration';\nimport { MatchingNodesSubscription, MatchingNodesChangedEvent } from '../subscriptions/matching_nodes_subscription';\n\nexport { NodeMatcher, ScopeExecutor };\n\nexport class SelectDeclaration extends ScopeTrackingDeclaration {\n    protected subscription: MatchingNodesSubscription;\n    protected matcher: NodeMatcher;\n    protected executor: ScopeExecutor;\n\n    constructor(node: Node, matcher: NodeMatcher, executor: ScopeExecutor) {\n        super(node);\n\n        this.matcher = matcher;\n        this.executor = executor;\n\n        this.subscription = new MatchingNodesSubscription(this.node, this.matcher, (event: MatchingNodesChangedEvent) => {\n            for(let node of event.addedNodes) {\n                this.addChildScopeByNode(node, this.executor);\n            }\n\n            for(let node of event.removedNodes) {\n                this.removeChildScopeByNode(node);\n            }\n        });\n    }\n\n    inspect(includeSource?: boolean): void {\n        (<any>console.groupCollapsed)('select', this.matcher);\n\n        try{\n            this.inspectChildScopes(includeSource);        \n        }finally{\n            console.groupEnd();\n        }\n    }\n}","import { Declaration } from './declaration';\nimport { TrivialSubscription, SubscriptionExecutor } from '../subscriptions/trivial_subscription';\n\nexport { SubscriptionExecutor };\n\nexport class UnmatchDeclaration extends Declaration {\n    protected subscription: TrivialSubscription;\n    protected executor: SubscriptionExecutor;\n\n    constructor(node: Node, executor: SubscriptionExecutor) {\n        super(node);\n\n        this.executor = executor;\n\n        this.subscription = new TrivialSubscription(this.node, { disconnected: true }, this.executor);\n    }\n\n    inspect(): void {\n        console.groupCollapsed('unmatches');\n        console.log(this.executor);\n        console.groupEnd();\n    }\n}","import { ScopeTrackingDeclaration, NodeMatcher, ScopeExecutor } from './scope_tracking_declaration';\nimport { NodeMatchesSubscription, NodeMatchesChangedEvent } from '../subscriptions/node_matches_subscription';\n\nexport { NodeMatcher, ScopeExecutor };\n\nexport class WhenDeclaration extends ScopeTrackingDeclaration {\n    protected subscription: NodeMatchesSubscription;\n    protected matcher: NodeMatcher;\n    protected executor: ScopeExecutor;\n\n    constructor(node: Node, matcher: NodeMatcher, executor: ScopeExecutor) {\n        super(node);\n\n        this.matcher = matcher;\n        this.executor = executor;\n\n        this.subscription = new NodeMatchesSubscription(this.node, this.matcher, (event: NodeMatchesChangedEvent) => {\n            if(event.isMatching) {\n                this.addChildScopeByNode(this.node, this.executor);\n            }else{\n                this.removeChildScopeByNode(this.node);\n            }\n        });\n    }\n\n    inspect(includeSource?: boolean): void {\n        (<any>console.groupCollapsed)('when', this.matcher);\n\n        try{\n            this.inspectChildScopes(includeSource);        \n        }finally{\n            console.groupEnd();\n        }\n    }\n}","export interface NodeVistor { (node: Node): NodeMatcher | boolean }\nexport declare type NodeMatcher = string | NodeListOf<Node> | Node[] | NodeVistor;\n\nexport class NodeCollector {\n    private static instance: NodeCollector;\n    \n    private static readonly ELEMENT_MATCHER_TYPE_ERROR_MESSAGE = \"Decl: An `NodeMatcher` must be a CSS selector (string) or a function which takes a node under consideration and returns a CSS selector (string) that matches all matching nodes in the subtree, an array-like object of matching nodes in the subtree, or a boolean value as to whether the node should be included (in this case, the function will be invoked again for all children of the node).\";\n\n    static isMatchingNode(rootNode: Node, nodeMatcher: NodeMatcher): boolean {\n        return this.getInstance().isMatchingNode(rootNode, nodeMatcher);\n    }\n\n    static collectMatchingNodes(rootNode: Node, nodeMatcher: NodeMatcher): Node[] {\n        return this.getInstance().collectMatchingNodes(rootNode, nodeMatcher);\n    }\n\n    private static getInstance() : NodeCollector {\n        return this.instance || (this.instance = new NodeCollector());\n    }\n\n    isMatchingNode(node: Node, nodeMatcher: NodeMatcher): boolean {\n        switch(typeof(nodeMatcher)) {\n            default:\n                throw new TypeError(NodeCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n                \n            case 'string':\n                let cssSelector: string = <string>nodeMatcher;\n                return this.isMatchingNodeFromCssSelector(node, cssSelector);\n            \n            case 'object':\n                let object = <Object>nodeMatcher;\n                return this.isMatchingNodeFromObject(node, object);\n                \n            case 'function':\n                let nodeVistor = <NodeVistor>nodeMatcher;\n                return this.isMatchingNodeFromNodeVistor(node, nodeVistor);       \n        }\n    }\n\n    collectMatchingNodes(node: Node, nodeMatcher: NodeMatcher): Node[] {\n        switch(typeof(nodeMatcher)) {\n            default:\n                throw new TypeError(NodeCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n                \n            case 'string':\n                let cssSelector: string = <string>nodeMatcher;\n                return this.collectMatchingNodesFromCssSelector(node, cssSelector);\n\n            case 'object':\n                let object = <Object>nodeMatcher;\n                return this.collectMatchingNodesFromObject(node, object);\n                \n            case 'function':\n                let nodeVistor = <NodeVistor>nodeMatcher;\n                return this.collectMatchingNodesFromNodeVistor(node, nodeVistor);       \n        }\n    }\n\n    private isMatchingNodeFromCssSelector(node: Node, cssSelector: string): boolean {\n        if(node instanceof Element && typeof(node.matches) === 'function') {\n            return node.matches(cssSelector);\n        }else{\n            return isMemberOfArrayLike(node.ownerDocument.querySelectorAll(cssSelector), node);            \n        }\n    }\n\n    private isMatchingNodeFromObject(node: Node, object: Object): boolean {\n        if(object === null) {\n            return false;\n        }else{\n            if(isArrayLike(object)) {\n                let arrayLike = <ArrayLike<any>>object;\n\n                if(arrayLike.length === 0 || arrayLike[0] instanceof Node) {\n                    return isMemberOfArrayLike(arrayLike, node);                \n                }else{\n                    throw new TypeError(NodeCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n                }\n            }else{\n                throw new TypeError(NodeCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n            }\n        }\n    }\n\n    private isMatchingNodeFromNodeVistor(node: Node, nodeVistor: NodeVistor): boolean {\n        let visitorResult = nodeVistor(node);\n\n        if(typeof(visitorResult) === 'boolean') {\n            let isMatch = <boolean>visitorResult;\n            return isMatch;\n        }else{\n            let nodeMatcher = <NodeMatcher>visitorResult;\n            return this.isMatchingNode(node, nodeMatcher);\n        }\n    }\n\n    private collectMatchingNodesFromCssSelector(node: Node, cssSelector: string): Node[] {\n        if(node instanceof Element || node instanceof Document || node instanceof DocumentFragment) {\n            return toArray<Node>(node.querySelectorAll(cssSelector));\n        }else{\n            return [];\n        }\n    }\n\n    private collectMatchingNodesFromObject(_node: Node, object: Object): Node[] {\n        if(object === null) {\n            return [];\n        }else{\n            if(isArrayLike(object)) {\n                let arrayLike = <ArrayLike<any>>object;\n\n                if(arrayLike.length === 0 || arrayLike[0] instanceof Node) {\n                    return toArray<Node>(arrayLike);                \n                }else{\n                    throw new TypeError(NodeCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n                }\n            }else{\n                throw new TypeError(NodeCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n            }\n        }\n    }\n\n    private collectMatchingNodesFromNodeVistor(node: Node, nodeVistor: NodeVistor): Node[] {\n        let nodes: Node[] = [];\n        let childNodes = node.childNodes;\n        \n        for(let index = 0, length = childNodes.length; index < length; index++) {\n            let child = childNodes[index];\n            \n            if(child instanceof Node) {\n                let node: Node = child;\n                let visitorResult = nodeVistor(node);\n\n                if(typeof(visitorResult) === 'boolean') {\n                    let isMatch = <boolean>visitorResult;\n\n                    if(isMatch) {\n                        nodes.push(node);\n                    }\n                }else{\n                    nodes.push(...this.collectMatchingNodes(node, visitorResult));\n                }\n            }\n        }\n\n        return nodes;\n    }\n}\n\nexport default NodeCollector;\n\nfunction isArrayLike(value: any) {\n    return typeof(value) === 'object' && typeof(value.length) === 'number';\n}\n\nfunction toArray<T>(arrayLike: ArrayLike<T>): Array<T> {\n    if(isArrayLike(arrayLike)) {\n        return Array.prototype.slice.call(arrayLike, 0);\n    }else{\n        throw new TypeError('Expected ArrayLike');\n    }\n}\n\nfunction isMemberOfArrayLike(haystack: ArrayLike<any>,  needle: any) {\n    return Array.prototype.indexOf.call(haystack, needle) !== -1;\n}\n","import { Declaration, SubscriptionExecutor } from './declarations/declaration';\nimport { MatchDeclaration } from './declarations/match_declaration';\nimport { UnmatchDeclaration } from './declarations/unmatch_declaration';\nimport { OnDeclaration, EventMatcher } from './declarations/on_declaration';\n\nimport { NodeMatcher } from './declarations/scope_tracking_declaration';\nimport { SelectDeclaration } from './declarations/select_declaration';\nimport { WhenDeclaration } from './declarations/when_declaration';\n\nexport { Declaration, SubscriptionExecutor, NodeMatcher, EventMatcher };\n\nexport interface ScopeExecutor { \n    (scope: Scope, node: Node): void\n};\n\nexport class Scope {\n    static buildRootScope(node: Node): Scope {\n        let scope = new Scope(node);\n        scope.activate();\n\n        return scope;\n    }\n\n    private readonly node: Node;\n    private readonly executors: ScopeExecutor[] = [];\n\n    private isActivated: boolean = false;\n    private declarations: Declaration[] = [];\n\n    constructor(node: Node, executor?: ScopeExecutor) {\n        this.node = node;\n\n        if(executor) {\n            this.addExecutor(executor);\n        }\n    }\n\n    addExecutor(executor: ScopeExecutor): void {\n        this.executors.push(executor);\n\n        return executor.call(this, this, this.node);\n    }\n\n    getNode(): Node {\n        return this.node;\n    }\n\n    getDeclarations(): Declaration[] {\n        return this.declarations;\n    }\n\n    inspect(includeSource?: boolean): void {\n        (<any>console.groupCollapsed)(this.node);\n\n        try {\n            if(includeSource) {\n                console.groupCollapsed('source');\n            \n                for(let executor of this.executors) {\n                    console.log(executor);\n                }\n\n                console.groupEnd();\n            }\n            \n            for(let declaration of this.declarations) {\n                declaration.inspect(includeSource);\n            }\n        }finally{\n            (<any>console.groupEnd)();\n        }\n    }\n\n    activate(): void {\n        if(!this.isActivated) {\n            this.isActivated = true;\n\n            for(let declaration of this.declarations) {\n                declaration.activate();\n            }\n        }\n    }\n\n    deactivate(): void {        \n        if(this.isActivated) {\n            this.isActivated = false;            \n            \n            for(let declaration of this.declarations) {\n                declaration.deactivate();\n            }\n        }\n    }\n\n    pristine(): void {\n        this.deactivate();\n        this.removeAllDeclarations();\n    }\n\n    match(executor: SubscriptionExecutor): Scope {\n        this.addDeclaration(new MatchDeclaration(this.node, executor));\n\n        return this;\n    }\n\n    unmatch(executor: SubscriptionExecutor): Scope {\n        this.addDeclaration(new UnmatchDeclaration(this.node, executor));\n\n        return this;\n    }\n\n    select(matcher: NodeMatcher, executor: ScopeExecutor): Scope {\n        this.addDeclaration(new SelectDeclaration(this.node, matcher, executor));\n\n        return this;\n    }\n\n    when(matcher: NodeMatcher, executor: ScopeExecutor): Scope {\n\t\tthis.addDeclaration(new WhenDeclaration(this.node, matcher, executor));\n\n        return this;\n    }\n\n    on(eventMatcher: EventMatcher, executor: SubscriptionExecutor): Scope;\n    on(eventMatcher: EventMatcher, nodeMatcher: NodeMatcher, executor: SubscriptionExecutor): Scope;\n    on(eventMatcher: EventMatcher, executorOrNodeMatcher: SubscriptionExecutor | NodeMatcher, maybeExecutor?: SubscriptionExecutor): Scope {\n        let argumentsCount = arguments.length;\n\n        switch(argumentsCount) {\n            case 2:\n                return this.onWithTwoArguments(eventMatcher, <SubscriptionExecutor>executorOrNodeMatcher);\n            case 3:\n                return this.onWithThreeArguments(eventMatcher, <NodeMatcher>executorOrNodeMatcher, <SubscriptionExecutor>maybeExecutor);\n            default:\n                throw new TypeError(\"Failed to execute 'on' on 'Scope': 2 or 3 arguments required, but \" + argumentsCount + \" present.\");\n        }\n    }\n\n    private onWithTwoArguments(eventMatcher: EventMatcher, executor: SubscriptionExecutor): Scope {\n        this.addDeclaration(new OnDeclaration(this.node, eventMatcher, executor));\n\n        return this;\n    }\n\n    private onWithThreeArguments(eventMatcher: EventMatcher, nodeMatcher: NodeMatcher, executor: SubscriptionExecutor): Scope {\n        this.select(nodeMatcher, (scope) => {\n            scope.on(eventMatcher, executor);\n        });\n\n        return this;\n    }\n\n    private addDeclaration(declaration: Declaration): void {\n        this.declarations.push(declaration);\n\n        if(this.isActivated) {\n            declaration.activate();\n        }\n    }\n\n    private removeDeclaration(declaration: Declaration): void {  \n        let index = this.declarations.indexOf(declaration);\n\n        if(index >= 0) {\n            this.declarations.splice(index, 1);\n        }\n\n        declaration.deactivate();        \n    }\n\n    private removeAllDeclarations() {        \n        let declaration: Declaration;\n\n        while(declaration = this.declarations[0]) {\n            this.removeDeclaration(declaration);\n        }\n    }\n}\n","import { Subscription, SubscriptionExecutor, SubscriptionEvent } from './subscription';\n\ninterface CommonJsRequire {\n    (id: string): any;\n}\n\ndeclare var require: CommonJsRequire;\nlet MutationObserver = require('mutation-observer'); // use polyfill\n\nexport abstract class BatchedMutationSubscription extends Subscription {\n    static readonly mutationObserverInit: MutationObserverInit = {\n        childList: true,\n        attributes: true,\n        characterData: true,\n        subtree: true\n    };\n\n    private isListening : boolean = false;\n    private handleMutationTimeout : any = null;\n\n    private readonly mutationCallback: MutationCallback;\n    private readonly mutationObserver: MutationObserver;\n\n    constructor(node: Node, executor: SubscriptionExecutor) {\n        super(node, executor);\n\n        this.mutationCallback = (): void => {\n            this.deferHandleMutations();\n        }\n\n        this.mutationObserver = new MutationObserver(this.mutationCallback);\n    }\n\n    protected startListening(): void {\n        if(!this.isListening) {\n            this.mutationObserver.observe(this.node, BatchedMutationSubscription.mutationObserverInit);\n\n            this.isListening = true;\n        }\n    }\n\n    protected stopListening(): void {\n        if(this.isListening) {\n            this.mutationObserver.disconnect();\n            this.handleMutationsNow();\n\n            this.isListening = false;\n        }\n    }\n    \n    protected abstract handleMutations(): void;\n\n    private deferHandleMutations(): void {\n        if(this.handleMutationTimeout === null) {\n            this.handleMutationTimeout = setTimeout(() => { \n                try {\n                    this.mutationObserver.takeRecords();\n                    this.handleMutations();\n                }finally{\n                    this.handleMutationTimeout = null;\n                }\n            }, 0);\n        }\n    }\n\n    private handleMutationsNow(): void {\n        if(this.handleMutationTimeout !== null) {\n            clearTimeout(this.handleMutationTimeout);\n            this.handleMutationTimeout = null;\n\n            this.handleMutations();            \n        }\n    }\n}\n\nexport { Subscription, SubscriptionExecutor, SubscriptionEvent };","import { Subscription, SubscriptionExecutor } from './subscription';\n\nexport { SubscriptionExecutor };\n\nexport class EventSubscription extends Subscription {\n    readonly eventMatcher: EventMatcher;\n    readonly eventNames: string[];\n\n    private isConnected : boolean = false;    \n    private readonly eventListener: EventListener;\n\n    constructor(node: Node, eventMatcher: EventMatcher, executor: SubscriptionExecutor) {\n        super(node, executor);\n\n        this.eventMatcher = eventMatcher;\n        this.eventNames = this.parseEventMatcher(this.eventMatcher);\n\n        this.eventListener = (event: Event): void => {\n            this.handleEvent(event);\n        }\n    }\n\n    connect(): void {\n        if(!this.isConnected) {\n            this.isConnected = true;\n\n            for(let eventName of this.eventNames) {\n                this.node.addEventListener(eventName, this.eventListener, false);\n            }\n        }\n    }\n\n    disconnect(): void {\n        if(this.isConnected) {\n            for(let eventName of this.eventNames) {\n                this.node.removeEventListener(eventName, this.eventListener, false);\n            }            \n\n            this.isConnected = false;\n        }\n    }\n\n    private handleEvent(event: Event): void {\n        this.executor(event, this.node);         \n    }\n\n    private parseEventMatcher(eventMatcher: EventMatcher): string[] {\n        // TODO: Support all of the jQuery style event options\n        return eventMatcher.split(' ');\n    } \n}\n\nexport declare type EventMatcher = string;\n","import { BatchedMutationSubscription, SubscriptionExecutor, SubscriptionEvent } from './batched_mutation_subscription';\nimport { NodeMatcher, NodeCollector } from '../node_collector';\n\nexport { NodeMatcher };\n\nexport class MatchingNodesSubscription extends BatchedMutationSubscription {\n    readonly matcher: NodeMatcher;\n\n    private isConnected: boolean = false;\n    private matchingNodes: Node[] = [];\n\n    constructor(node: Node, matcher: NodeMatcher, executor: SubscriptionExecutor) {\n        super(node, executor);\n\n        this.matcher = matcher;\n    }\n\n    connect(): void {\n        if(!this.isConnected) {\n            this.updateMatchingNode(this.collectMatchingNodes());\n            this.startListening();\n\n            this.isConnected = true;\n        }\n    }\n\n    disconnect(): void {\n        if(this.isConnected) {\n            this.stopListening();\n            this.updateMatchingNode([]);\n\n            this.isConnected = false;\n        }        \n    }\n\n    protected handleMutations(): void {\n        this.updateMatchingNode(this.collectMatchingNodes());\n    }\n\n    private updateMatchingNode(matchingNodes: Node[]): void {\n        let previouslyMatchingNodes = this.matchingNodes;\n\n        let addedNodes = arraySubtract(matchingNodes, previouslyMatchingNodes);\n        let removedNodes = arraySubtract(previouslyMatchingNodes, matchingNodes);\n\n        this.matchingNodes = matchingNodes;   \n        \n        if(addedNodes.length > 0 || removedNodes.length > 0) {\n            let event = new MatchingNodesChangedEvent(this, addedNodes, removedNodes);\n\n            this.executor(event, this.node);\n        }\n    }\n\n    private collectMatchingNodes(): Node[] {\n        return NodeCollector.collectMatchingNodes(this.node, this.matcher);\n    }\n}\n\nexport class MatchingNodesChangedEvent extends SubscriptionEvent {\n    readonly addedNodes: Node[];\n    readonly removedNodes: Node[];\n\n    constructor(matchingNodesSubscription: MatchingNodesSubscription, addedNodes: Node[], removedNodes: Node[]) {\n        super(matchingNodesSubscription, 'MatchingNodesChanged');\n\n        this.addedNodes = addedNodes;\n        this.removedNodes = removedNodes;\n    }\n}\n\nfunction arraySubtract<T>(minuend: T[], subtrahend: T[]): T[] {\n    let difference: T[] = [];\n\n    for(let member of minuend) {\n        if(subtrahend.indexOf(member) === -1) {\n            difference.push(member);\n        }\n    }\n\n    return difference;\n}","import { BatchedMutationSubscription, SubscriptionExecutor, SubscriptionEvent } from './batched_mutation_subscription';\nimport { NodeMatcher, NodeCollector } from '../node_collector';\n\nexport class NodeMatchesSubscription extends BatchedMutationSubscription {\n    readonly matcher: NodeMatcher;\n\n    private isConnected: boolean = false;\n    private isMatchingNode: boolean = false;\n\n    constructor(node: Node, matcher: NodeMatcher, executor: SubscriptionExecutor) {\n        super(node, executor);\n\n        this.matcher = matcher;\n    }\n\n    connect(): void {\n        if(!this.isConnected) {\n            this.updateIsMatchingNode(this.computeIsMatchingNode());\n            this.startListening();\n\n            this.isConnected = true;\n        }\n    }\n\n    disconnect(): void {\n        if(this.isConnected) {\n            this.stopListening();\n            this.updateIsMatchingNode(false);\n\n            this.isConnected = false;\n        }        \n    }\n\n    protected handleMutations(): void {\n        this.updateIsMatchingNode(this.computeIsMatchingNode());\n    }\n\n    private updateIsMatchingNode(isMatchingNode: boolean): void {\n        let wasMatchingNode = this.isMatchingNode;\n        this.isMatchingNode = isMatchingNode;\n\n        if(wasMatchingNode !== isMatchingNode) {\n            let event = new NodeMatchesChangedEvent(this, isMatchingNode);\n\n            this.executor(event, this.node);\n        }\n    }\n\n    private computeIsMatchingNode(): boolean {\n        return NodeCollector.isMatchingNode(this.node, this.matcher);\n    }\n}\n\nexport class NodeMatchesChangedEvent extends SubscriptionEvent {\n    readonly isMatching: boolean;\n\n    constructor(nodeMatchesSubscription: NodeMatchesSubscription, isMatching: boolean) {\n        super(nodeMatchesSubscription, 'NodeMatchesChangedEvent');\n\n        this.isMatching = isMatching;\n    }\n}\n\nexport { NodeMatcher };\n","export abstract class Subscription {\n    readonly executor: SubscriptionExecutor;\n    readonly node: Node;\n    \n    constructor(node: Node, executor: SubscriptionExecutor) {\n        this.node = node;\n        this.executor = executor;\n    }\n\n    abstract connect() : void;\n    abstract disconnect() : void;\n}\n\nexport interface SubscriptionExecutor { \n    (event: Event | SubscriptionEvent, node: Node): void \n}\n\nexport class SubscriptionEvent {\n    readonly subscription: Subscription;\n    readonly name: string;\n\n    constructor(subscription: Subscription, name: string) {\n        this.subscription = subscription;\n        this.name = name;\n    }\n}\n","import { Subscription, SubscriptionExecutor, SubscriptionEvent } from './subscription';\n\nexport { SubscriptionExecutor };\n\nexport interface TrivialSubscriptionConfiguration {\n    connected?: boolean,\n    disconnected?: boolean\n}\n\nexport class NodeConnectionChangedEvent extends SubscriptionEvent {\n    readonly node: Node;\n    readonly isConnected: boolean;\n\n    constructor(trivialSubscription: TrivialSubscription, node: Node, isConnected: boolean) {\n        super(trivialSubscription, 'NodeConnected');\n\n        this.node = node;\n        this.isConnected = isConnected;\n    }\n}\n\nexport class TrivialSubscription extends Subscription {\n    private isConnected: boolean = false;\n    private config: TrivialSubscriptionConfiguration;\n\n    constructor(node: Node, config: TrivialSubscriptionConfiguration, executor: SubscriptionExecutor) {\n        super(node, executor);\n\n        this.config = config;\n    }\n\n    connect() {\n        if(!this.isConnected) {\n            this.isConnected = true;\n\n            if(this.config.connected) {\n                this.executor(this.buildNodeConnectionChangedEvent(), this.node); \n            }\n        }\n    }\n\n    disconnect() {\n        if(this.isConnected) {\n            this.isConnected = false;\n\n            if(this.config.disconnected) {\n                this.executor(this.buildNodeConnectionChangedEvent(), this.node);     \n            }\n        }\n    }\n    \n    private buildNodeConnectionChangedEvent(): NodeConnectionChangedEvent {\n        return new NodeConnectionChangedEvent(this, this.node, this.isConnected);\n    }\n}"]}